$T1\ Hat$

算法 $1:\ 10pts$

$n\leq 5$

各种随心所欲的大暴力。



算法 $2:\ 30pts$

$n\leq 5000$

我也不知道这个部分分怎么写，我觉得可能也没人写这个。


算法 $3:\ 10pts$

$A_i,B_i\leq 1$

所有数字都很小，枚举$A_1$后就知道了异或总和，然后依次求出$A_i$即可。


算法 $4:\ 100 pts$

真正的数据范围

签到题，不妨设异或总和为$S$，则$B_i=A_i\oplus S$，考虑所有$B_i$的异或和，相当于$n$个$S$异或后再异或上$A_i$的异或和（也是$S$），也就是$n+1$个$S$进行异或。由于$n$是偶数，则$n+1$必然是奇数。这样求出来的结果直接就是$S$，得到$S$后将其异或上每一个$B_i$就得到了$A_i$。








$T2\ String$

算法 $1:\ 20pts$

$n\leq 20$

状压$DP$、$Dfs$等等暴力解法，随便乱做都行。



算法 $2:\ 50pts$

$n\leq 5000$

我也不知道这个部分分怎么写，但是可能有人会写，希望能讲讲$XD$。



算法 $3:\ 10pts$

单词长度全部为$1$

这个部分分可以方便你比较不同的单词，也把单词数量控制在了$26$个以内。我还是不会写，但有人可能会写，希望能讲讲$XD$。



算法 $4:\ 100 pts$

真正的数据范围

送分题，先用哈希/$map$/排序等等简单的算法把单词转变为可以轻易比较的数字。
考虑$f_i$表示前$i$个单词组成的句子，能变出多少种不同的新句子，

1. 第$i$个单词可以保留在原位，即$f_i+=f_{i-1}$
2. 第$i$个单词可以与第$i-1$个单词互换位置，即$f_i+=f_{i-2}$ ，要求满足这两个单词不同（否则交换没有意义）。

简单的证明：

长度为$n$的句子里，$n$的位置只能是$n$或$n-1$，如果是$n$则可以归纳到$n-1$的情况；如果是$n-1$，则$n-1$必须在$n$的位置上（否则会导致前面某个数必须到$n+1$及以后的位置，违反了限制）所以又可以归纳到$n-2$的情况。







$T3\ Globe$

算法 $1:\ 10pts$

$n\leq 10$

枚举每一个矩形的形状后暴力统计即可，复杂度$O(n\cdot4^n)$。



算法 $2:\ 20pts$

$n\leq 20$

发现横纵坐标互不相关，对于横纵坐标分别枚举求出最大值，再相乘即可，复杂度$O(n\cdot2^n)$。



算法 $3:\ 50pts$

$n\leq 3000$

仍然先将横纵坐标分开做。对坐标进行离散化，发现每一段被关键点夹在中间的线段，想要被选中就一定存在唯一确定的矩形覆盖方案。对于每段线段，将其他线段扫一遍，求出和自己的需求一致的线段长度和，再取最大值，复杂度$O(n^2)$，算法$4$的不当复杂度可能会挂到这个档。



算法 $4:\ 100 pts$

原题范围

沿用算法 $3$ 的做法，用哈希表示每一段线段的需求，然后对哈希值相同的线段进行累加即可，复杂度$O(n\log n)$，瓶颈为排序。注意不要使用$map$等带$\log$的做法来让本就不富裕的常数雪上加霜，建议手写哈希或者用$unordered\_map$ ~~（开$C++11$就是因为标程用了这玩意儿）~~。







$T4\ Sequence$

算法 $1:\ 10pts$

$n\leq 100$

枚举每一个区间，从小到大依次将相同的数合并为一个更大的数，直到最后合并为一个数即为合法，复杂度$O(n^3)$或$O(n^3\log n)$，取决于实现方式，都能过。



算法 $2:\ 20pts$

$n\leq 1000$

枚举每一个区间，发现最后组合成的数的指数大小一定不会超过区间中最大的数太多，不妨设区间最大的数为$x$，用哈希依次对每一个在$[0,\log n]$之间的$i$判断区间和是否等于$2^{x+i}$，复杂度$O(n^2\log n)$。



算法 $3:\ 50pts$

$n\leq 5000$

$O(n^2)$的档，我不会做，后面复杂度炸了或常数问题可能会掉到这个档，有人会的话请一定要讲讲$XD$。



算法 $4:\ 80 pts$

$n\leq 50000$

考虑每个数$x$作为区间最大数，可以建立出一棵笛卡尔树。对于$x$管辖的区间，不管如何合并，总和一定不会超过$x+\log n$。我们维护一下每个区间前后缀的哈希值，对于中心点$x$，枚举所有可能的幂次，再从数字少的一边枚举一个前缀或后缀（类似启发式合并），在另一边用$map$或$multiset$等工具查询对应的互补的值的个数即可。然后合并两个区间依然是用到启发式合并，点少的半边直接暴力插入，点多的半边全体打个标记。复杂度$O(n\log^3 n)$，瓶颈在于查询。



算法 $5:\ 40pts$

$a_i\leq2$或$a_i\leq 30$

此时合并后的幂次不会很大，最多不会超过$50$，枚举幂次的值，维护一个前缀和，再枚举每个点为右端点，用算法$4$的思想即可，复杂度$O(50\cdot n\log n)$。



算法 $6:\ 100pts$

原题数据范围

依然是算法$4$的思想，不用$map$和$multiset$，我们不关心哈希值的大小关系，直接手写哈希表或者用$unordered\_map$，复杂度优化掉一个$log$，最终复杂度为$O(n\log^2 n)$，春宵苦短，少年卡常吧！