# P2680 [NOIP2015 提高组] 运输计划

[题目链接](https://www.luogu.com.cn/problem/P2680)
LCA的题，需要求最大值最小，考虑二分答案。
先存储每组询问的距离。
然后二分答案时找出所有比当前答案长的距离的重叠部分。
在这些重叠部分中找出权值最大的边。
判断最长链减去这条边是否小于等于当前答案。否则返回0 
代码如下
```
/*
 * @Author: Ishar-zdl 
 * @Date: 2023-09-29 06:43:26 
 * @Last Modified by: Ishar-zdl
 * @Last Modified time: 2023-09-29 09:57:58
 */
#include<bits/stdc++.h>
using namespace std;
const int MAXN=3e5+10;
int n,m,dep[MAXN],a[MAXN],dis[MAXN],f[MAXN][20];
int to[MAXN<<1],nxt[MAXN<<1],head[MAXN],val[MAXN<<1],cnt;
int d[MAXN],CNT,ans;
inline void add(int x,int y,int v)
{
    to[++cnt]=y,nxt[cnt]=head[x];
    head[x]=cnt,val[cnt]=v;return ;
}
struct node{int a,b,d,L;}p[MAXN];
void dfs(int x,int fa=0)
{
    dep[x]=dep[fa]+1,dis[x]=dis[fa]+a[x];f[x][0]=fa;
    for(register int i=1;i<=__lg(dep[x]);++i)
        f[x][i]=f[f[x][i-1]][i-1];
    for(register int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa) continue;
        a[y]=val[i];dfs(y,x);
    }
    return ;
}
inline int lca(int x,int y)
{
    if(dep[x]<dep[y]) swap(x,y);
    while(dep[x]>dep[y]) x=f[x][__lg(dep[x]-dep[y])];
    if(x==y) return x;
    for(register int i=__lg(dep[x]);i>=0;--i)
        if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    return f[x][0];
}
void Do(int x,int fa=0)
{
    for(register int i=head[x];i;i=nxt[i])
    {
        int y=to[i];if(y==fa) continue;
        Do(y,x);d[x]+=d[y];
    }
    if(d[x]==CNT) ans=max(ans,a[x]);return ;
}
inline bool check(int x)
{
    CNT=ans=0;int M=0;
    for(register int i=1;i<=n;++i) d[i]=0;
    for(register int i=1;i<=n;++i)
    {
        if(p[i].d>x)
        {
            ++CNT;
            d[p[i].a]++,d[p[i].b]++;
            d[p[i].L]-=2;M=max(M,p[i].d);
        }
    }
    Do(1,0);return (M-ans<=x);
}
int main()
{
#ifdef ONLINE_JUDGE
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
#endif
    cin>>n>>m;int l=0,r=0;
    for(register int i=1;i<n;++i)
    {
        int x,y,v;cin>>x>>y>>v;
        add(x,y,v),add(y,x,v);
    }
    dfs(1);
    for(register int i=1;i<=m;++i)
    {
        cin>>p[i].a>>p[i].b;p[i].L=lca(p[i].a,p[i].b);
        p[i].d=dis[p[i].a]+dis[p[i].b]-(dis[p[i].L]<<1);
        r=max(r,p[i].d);
    }
    while(l<r)
    {
        int mid=(l+r)>>1;
        (check(mid))?r=mid:l=mid+1;
    }
    cout<<l<<'\n';return 0;
}
```
最后感谢 [int_R](https://www.luogu.com.cn/user/469312)担任我的脑机接口，将我的思路映射出来![](https://cdn.luogu.com.cn/upload/image_hosting/kt8ztji9.png)  



---



# P2155 [SDOI2008] 沙拉公主的困惑

[题目](https://www.luogu.com.cn/problem/P2155)
题面非常的简洁，求 $1$ $\sum\limits_{i=1}^{n!}[i\perp m!]$ 
直接颓式子，
$$
\begin{aligned}
ans&=\dfrac{n!}{m!}\cdot\varphi(m!)\\\\
&=\dfrac{n!}{m!}*m!\prod\limits_{p\mid m!}[\dfrac{p-1}{p}]\\
&=n!\cdot\dfrac{\prod\limits_{p\in\mathbb{P},p\le m}(p-1)}{\prod\limits_{p\in\mathbb{P},p\le m}p}
\end{aligned}
$$
p为1到m中的所有质数，逆元和阶乘预处理直接乘起来就行。
小粉兔提出模数可能会小于n，
当 $mod\le m\le n$ 时，逆元遇到 $p\mid i$ 时，$inv_i=1$ ，然后阶乘时要判断，因为分子和分母可以消去 p 。
而当 $m<mod\le n$ 时，即不能消去 p 时就直接输出0 。
感觉这道题有点毒瘤。
代码如下

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int prime[(int)(1e6)+5],
ny[(int)(1e7)+5],num[(int)(1e7)+5],
x,y,cj[(int)(1e6)+5];
int jie[(int)(1e7)+5];
bool vis[(int)(1e7)+5];
void getprime(int n){
    int m=0;
    for(int i=2;i<=n;i++){
        if(!vis[i])prime[++m]=i;num[i]=m;
        for(int j=1;j<=m&&prime[j]*i<=n;++j){
            vis[prime[j]*i]=1;
            if(i%prime[j]==0)break;
        }
    }
}
int read(){
    int x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
void write(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
main(){
    int t,p,n,m;t=read();p=read();ny[0]=ny[1]=1;getprime((int)(1e7)+2);
    for(int i=2;i<=1e7;++i){ny[i]=(p-p/i)*ny[p%i]%p;}
    jie[1]=1;cj[0]=1;
    for(int i=2;i<=(int)(1e7)+1;++i)
        if(i==p)
            jie[i]=jie[i-1];
        else
            {jie[i]=i*jie[i-1]%p;}
    for(int i=1;i<=num[(int)1e7];++i){cj[i]=(prime[i]-1)*cj[i-1]%p*ny[prime[i]%p]%p;}
    while(t--){
        n=read(),m=read();
        if(n>=p&&m<p)
        {
            puts("0");
            continue; 
        }
        n=jie[n];int pre=num[m];
        write(n*cj[pre]%p);
        putchar('\n');
    }
    return 0;
}
/*
1 3
4 3
*/
```
另外可以优化，只处理 $max(n)$ 即可。最优解就是这么卡的。
# P2048 [NOI2010] 超级钢琴
[题目链接](https://www.luogu.com.cn/problem/P2048)
RMQ好题，但是不知道为啥hzoi放到了lca的题单  

这道题思路想了一半然后卡了，不知道怎么处理重复贡献的问题。     
然后he了眼题解，茅塞顿开。可以再次将最优分成两个，再次计算。  
全程维护音符的前缀和，和区间最大值。
结构体内存最大值，左端点，右端点范围，以及右端点。
考虑先枚举左端点 $i$ 到右端点 $i+L-1$ 到 $i+R-1$ ，找出最大值。
然后将它压入优先队列。
枚举完之后，取出队头，将队头分成两部分（如果能的话），算出这两个区间的最大值后再压入队列。
这样取出 $k$ 次后，就是乐曲美妙度最大值。
代码  
```
/*
 * @Author: Ishar-zdl 
 * @Date: 2023-10-02 09:54:48 
 * @Last Modified by: Ishar-zdl
 * @Last Modified time: 2023-10-02 16:10:20
 */
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
inline void write(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
struct Skadi{
    int o,l,r,x,t;bool operator<(Skadi b)const{return x<b.x;}
};
const int N=5e5+10;
int n,k,L,R,A[N],a[N],st[N][20],num[N][20];
priority_queue<Skadi> q;
inline void in(){
    n=read(),k=read(),L=read(),R=read();
    for(int i=1;i<=n;i++)A[i]=read(),a[i]=A[i]+a[i-1],st[i][0]=a[i],num[i][0]=i;
}
inline void stt(){
    for(int i=1;i<=20;++i)
        for(int j=1;j+(1<<i)-1<=n;++j)
            if(st[j][i-1]>st[j+(1<<(i-1))][i-1])num[j][i]=num[j][i-1],st[j][i]=st[j][i-1];
            else num[j][i]=num[j+(1<<(i-1))][i-1],st[j][i]=st[j+(1<<(i-1))][i-1];
}
inline void work(){
    Skadi zc;
    for(int i=1;i+L-1<=n;++i){
        zc.o=i,zc.l=i+L-1,zc.r=min(i+R-1,n);
        int k=__lg(zc.r-zc.l+1);
        int A=st[zc.l][k],B=st[zc.r-(1<<k)+1][k];
        if(A>B)zc.x=A-a[i-1],zc.t=num[zc.l][k];
        else zc.x=B-a[i-1],zc.t=num[zc.r-(1<<k)+1][k];
        q.push(zc);
    }long long tot=0,ans=0;
    while(tot<k){
        zc=q.top(),q.pop(),ans+=zc.x;tot++;
        if(zc.t!=zc.l){
            int k=__lg(zc.t-zc.l);int A=st[zc.l][k],B=st[zc.t-(1<<k)][k];int x,t;
            if(A>B)x=A-a[zc.o-1],t=num[zc.l][k];
            else x=B-a[zc.o-1],t=num[zc.t-(1<<k)][k];
            q.push({zc.o,zc.l,zc.t-1,x,t});
        }
        if(zc.t!=zc.r){
            int k=__lg(zc.r-zc.t);int A=st[zc.t+1][k],B=st[zc.r-(1<<k)+1][k];int x,t;
            if(A>B)x=A-a[zc.o-1],t=num[zc.t+1][k];
            else x=B-a[zc.o-1],t=num[zc.r-(1<<k)+1][k];
            q.push({zc.o,zc.t+1,zc.r,x,t});
        }
    }
    write(ans);
}
int main(){
    in();
    stt();
    work();
    return 0;
}
```
___
# P2486 [SDOI2011] 染色
[题目链接](https://www.luogu.com.cn/problem/P2486)
分两段，最后靠同一条重链合
树剖加线段树，典中典。  
这题的线段树维护比较新颖。
线段树中维护这个区间左右端点的颜色和颜色段数量。  
建树和查询和修改时要判断左区间的右端点和右区间的左端点是否颜色相同。  
如果不相同，直接将段数相加，否则减一。  
然后就是查询路径时，可以想象成两端点相遇，分成两部分。  
然后每部分合并时判断连接处是否颜色一样。  
最后两部分合并时，判断最后一条链和左右部分的相连处颜色是否相同。（注意，左右顺序）
我们可以通过dfs序，来判断左右部分。  
然后其他就是树剖和线段树的板子。  

代码
```
/*
 * @Author: Ishar-zdl 
 * @Date: 2023-10-04 15:48:52 
 * @Last Modified by: Ishar-zdl
 * @Last Modified time: 2023-10-05 15:16:50
 */
#include<bits/stdc++.h>
using namespace std;
#define lc (p<<1)
#define rc (p<<1|1)
inline int read(){
    int x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
inline void write(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
const int N=1e5+5;
int tl,tr;
int tll,tlr,trl,trr,ansr,ansl;
int n,m,tot,head[N],top[N],w[N],fa[N],son[N],siz[N],dep[N],dfn[N],rnk[N];
struct edge{
    int v,next;
}e[N*4];
struct segment_tree{
    int ls,rs,l,r,sum,cha;
    #define ls(p)  t[p].ls
    #define rs(p)  t[p].rs
    #define l(p)   t[p].l
    #define r(p)   t[p].r
    #define sum(p) t[p].sum
    #define cha(p) t[p].cha
}t[N*4];
void add(int u,int v){
    e[++tot]={v,head[u]};head[u]=tot;
}
void dfs1(int x){
    siz[x]=1;
    for(int i=head[x],y;i;i=e[i].next)
        if(!dep[y=e[i].v]){
            fa[y]=x;dep[y]=dep[x]+1,dfs1(y),siz[x]+=siz[y];
            if(!son[x]||siz[y]>siz[son[x]])son[x]=y;
        }
}
void dfs2(int x,int t){
    dfn[x]=++tot;rnk[tot]=x;top[x]=t;
    if(son[x])dfs2(son[x],t);
    for(int i=head[x],y;i;i=e[i].next){
        y=e[i].v;
        if(y!=fa[x]&&y!=son[x])dfs2(y,y);
    }
}
void build(int p,int l,int r){
    l(p)=l,r(p)=r;
    if(l==r){rs(p)=ls(p)=w[rnk[l]],sum(p)=1;return;}
    int mid=l(p)+r(p)>>1;
    build(lc,l,mid),build(rc,mid+1,r);
    ls(p)=ls(lc),rs(p)=rs(rc),sum(p)=sum(lc)+sum(rc);
    if(rs(lc)==ls(rc))sum(p)--;
}
inline void pushdown(int p){
    if(!cha(p))return;
    ls(lc)=rs(lc)=ls(rc)=rs(rc)=cha(lc)=cha(rc)=cha(p);
    sum(lc)=sum(rc)=1;
    cha(p)=0;
}
inline void update(int p,int l,int r,int k){
    if(l<=l(p)&&r>=r(p)){
        ls(p)=rs(p)=k;sum(p)=1,cha(p)=k;
        return;
    }pushdown(p);
    int mid=l(p)+r(p)>>1;
    if(l<=mid)update(lc,l,r,k);
    if(r>mid)update(rc,l,r,k);
    sum(p)=sum(lc)+sum(rc);
    if(rs(lc)==ls(rc))sum(p)--;
    ls(p)=ls(lc),rs(p)=rs(rc);
}
inline void modified(int u,int v,int k){
    int fu=top[u],fv=top[v];
    while(fu!=fv){
        if(dep[fu]>dep[fv])update(1,dfn[fu],dfn[u],k),u=fa[fu],fu=top[u];
        else update(1,dfn[fv],dfn[v],k),v=fa[fv],fv=top[v];
    }
    if(dep[u]>dep[v])swap(u,v);
    update(1,dfn[u],dfn[v],k);
}
inline int ask(int p,int l,int r){
    if(l<=l(p)&&r>=r(p)){
        if(tl==0){tl=ls(p);tr=rs(p);return sum(p);}
        if(ls(p)==tr){tr=rs(p);return sum(p)-1;}
        tr=rs(p);return sum(p);
    }
    pushdown(p);
    int mid=l(p)+r(p)>>1,ans=0;
    if(l<=mid)ans+=ask(p<<1,l,r);
    if(r>mid)ans+=ask(p<<1|1,l,r);
    return ans;
}
inline void query(int u,int v){
    tl=tr=0;
    tll=tlr=trl=trr=ansl=ansr=0;
    int fu=top[u],fv=top[v],ans1=0,ans2=0;
    while(fu!=fv){
        if(dep[fu]>dep[fv]){
            ans1+=ask(1,dfn[fu],dfn[u]),u=fa[fu],fu=top[u];
            if(ansr==tr)ans1--;
            ansr=tl;
        }
        else{
            ans2+=ask(1,dfn[fv],dfn[v]),v=fa[fv],fv=top[v];
            if(ansl==tr)ans2--;
            ansl=tl;
        }
        tl=tr=0;
    }
    if(dfn[u]>dfn[v])swap(u,v),swap(ansr,ansl);
    
    int ans=ans1+ans2+ask(1,dfn[u],dfn[v]);
    if(tl==ansr)ans--;
    if(tr==ansl)ans--;
    write(ans);putchar('\n');
}
int main(){
    // freopen("date.in","r",stdin);freopen("date.out","w",stdout);
    n=read(),m=read();fa[1]=dep[1]=1;
    for(int i=1;i<=n;i++)w[i]=read();
    for(int i=1,u,v;i<n;i++)
        u=read(),v=read(),add(u,v),add(v,u);
    dfs1(1);tot=0;dfs2(1,1);build(1,1,n);
    for(int i=1,u,v,k;i<=m;i++){
        char s;cin>>s;
        u=read(),v=read();
        if(s=='Q')query(u,v);
        if(s=='C') k=read(),modified(u,v,k);
    }
    return 0;
}
```
附:这题调了一下午。
___

# P1896 [SCOI2005] 互不侵犯
当前国王数，行数，当前行的状态为DP的下标。
# P2831 [NOIP2016 提高组] 愤怒的小鸟
待定vector查找的做法

# P2167 [SDOI2009] Bill的挑战
应该是容斥加状压
```
5

3 3

???r???

???????

???????

3 4

???????

?????a?

???????

3 3

???????

?a??j??

????aa?

3 2

a??????

???????

???????

3 2

???????

???a???

????a??
```
$C^0_4+C^1_3+C^2_2=1+3+1=5$ 
$2\ \ 3\ \ 5\ \ 8\ \ 13\ \ 21\ \ 34$   
$f_i=f_{i-1}+f_{i-2}$ 
# P1879 [USACO06NOV] Corn Fields G
算是最简单的状压吧，为啥评蓝![[061ACFD5.png]]
# P3052 [USACO12MAR] Cows in a Skyscraper G
喜报，绿不会了，g数组转移真逆天
# P3451 [POI2007] ATR-Tourist Attractions 旅游景点
先给源点1和要到达的点都跑一遍dij,时间复杂度 $O(kn\log n)$ ,好像后面就是挺明显的状压了.
卡空间是真的垃圾.现在只过了hzoi的
现在都过了,卡空间的能不能414啊
滚动数组还没看.
# P3622 [APIO2007] 动物园
每个位置最多能影响到五个位置的人.
然后可以考虑枚举任意五个位置做状压,找最优的方案.
思路差不多,$dp_{i,s}$ 表示第 $i$ 个位置起五个位置的 $s$ 状态下最多能满足几个人的要求.
$num_{i\ s}$ 表示第 $i$ 个位置起五个位置的 $s$ 状态下能满足几个开头是 $i$ 位置的人得要求.
状态转移方程
$$dp_{i,s}=max(dp_{i-1,s\& 15<<1},dp_{i-1,(s\& 15<<1)|1})+num_{i,s}$$
关于环需要枚举前五个的32种状态.
# P3226 [HNOI2012] 集合选数
一眼不会,
看题解:卧槽,太妙了
![[0D238C0D.jpg]]
破防了哥,你什么都没做错

# P4159 [SCOI2009] 迷路
[题目链接](https://www.luogu.com.cn/problem/P4159)
首先我们先考虑这道题的弱化版如何处理。假如所有的边权都是零和一。
这时他们的边权可以看做这两个点走一步到达之间的方案数。  
而对于走 t 步，我们可以推出下列式子, $f_{i,j}$ 表示从节点 $i$ 到节点 $j$ 的方案数。
$$f_{i,j}=\sum {f_{i,k}\cdot f_{k,j}}$$
是不是很熟悉,我们发现它就是矩阵乘法的式子。
对于这个，这里有一道题[P2233 [HNOI2002] 公交车路线](https://www.luogu.com.cn/problem/P2233)，我们直接考虑矩阵加速，即可求出。
###### 回到这道题

通过观察，我们发现他的每一个边权都很小，不会超过九（其实这就暗示了解法）  
我们不妨考虑把每一个点拆成9个边权为1或0的点，可以这样想象（当然也有另外的拆法，大同小异）
我们可以将第一个点拆成 $1.0\ ,\ 1.1,\ 1.2,\ 1.3,\dots \ 1.8,\ 1.8$ 
其中 $1.0$ 代表的就是这个点，我们可以叫他“真点”
而对于 $1.i$ 这样的点，它代表距离“真点” $1$ 距离为 $i$ 的点，我们叫它“假点”。
$2\leq n\leq 10$ ,所以我们可以拆成 $9n\cdot 9n$ 的矩阵。
在读入边权之前，我们需要将每个点的后八个假点每两个相邻的连接，边权为1 。
对于边权 $u,v,w$，我们将 $u$ 连到 $v.w$ 边权为1
这样就构造出了矩阵。然后直接跑矩阵快速幂就行。
对于求第 $t$ 步的方案数，时间复杂度为 $O(\ \ (9n)^3\log t\ \ )$ 
代码如下
```cpp
/*
 * @Author: Ishar-zdl 
 * @Date: 2023-10-14 15:03:04 
 * @Last Modified by: Ishar-zdl
 * @Last Modified time: 2023-10-15 07:51:30
 */
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
inline void write(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
const int mod=2009,N=95;
struct mt{
    int n,t[N][N];
    inline mt(){memset(t,0,sizeof(t));}
    inline void clear(){
        memset(t,0,sizeof(t));
        for(int i=1;i<=n;++i)t[i][i]=1;
    }
    inline mt operator*(const mt&b)const{
        mt res;int r;res.n=b.n;
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j){
                for(int k=1;k<=n;++k)
                    res.t[i][j]+=t[i][k]*b.t[k][j];
                res.t[i][j]%=mod;
            }
        return res;
    }
    inline mt operator^(int p)const{
        mt res,x=*this;res.n=x.n;
        res.clear();
        for(;p;p>>=1,x=x*x)
            if(p&1)res=res*x;
        return res;
    }
}base;
int main(){
    // freopen("in.in","r",stdin);
    // freopen("out.out","w",stdout);
    int n=read(),q=read();base.n=9*n;
    int a;
    for(int i=1;i<=n;++i){
        for(int zc=i*9-7;zc<=i*9;zc++)
            base.t[zc][zc-1]=1;
        for(int j=1;j<=n;++j){
            scanf("%1d",&a);
            if(a)
            base.t[i*9-8][j*9-9+a]=1;
        }
    }
    base=base^q;
    write(base.t[1][n*9-8]);
    return 0;
}
```
---
# P3167 [CQOI2014] 通配符匹配
哈希加DP，$*$ 和 $?$ 相当于把这个字符串分成若干个字符串，然后依次匹配。
关于 $*$ :严格要求上一个匹配位置在当前往前第二个位置上.
对于 $?$ :无任何要求.
综上,设 $dp_{i,j}$ 表示匹配到第 $i$ 个位置,匹配第 $j$ 个串时的匹配串数.可以写出状态转移方程.
$$dp_{i,j}=dp_{i-1,j-1}$$