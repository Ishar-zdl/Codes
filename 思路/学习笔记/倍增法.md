倍增运用二进制划分的思想
感觉和二分很像
每次令 $p$ 成倍增长，超出后令 $p/=2$ ,当 $p=0$ 时停止。
可以用来处理 RMQ 问题，$O(N\log N)$ 预处理，查询 $O(1)$ 复杂度
猫树复杂度 $O(N\log N)$ 
话说我好像是要学树剖，然后看lca，然后就到倍增了

知乎
### 区间最值问题

让我们来看一个新的问题：给定一个长度为 n 的序列 $a[1],a[2],\cdots,a[n]$， m 次询问，每次询问 l 到 r 范围内的区间最大值。 n 的规模是 100000 ， m 的规模是 10000000 。

朴素的线段树或树状数组算法处理这个问题都会慢很多。我们希望能得到一个时间复杂度与 m 线性相关的算法。出人意料的是，**倍增算法**能完美给出一个回答。

我们如何求区间的最值呢？读者可能很快想到，将 l 到 r 这一段区间划分成若干个小区间，每个小区间的长度都是 2 的幂次。而我们如何预处理这些 2 的幂次长度的区间的最大值呢？可以通过预处理倍增数组

$F[i][j]=\max\{a[i],a[i+1],\cdots,a[i+2^j-1\}$

那么利用关系式 $F[i][j+1]=\max\{F[i][j],F[i+2^j][j]\}$ ，我们可以用 $O(n\log n)$ 的时间复杂度预处理倍增数组，这部分方法和前面提到的是一样的。

不过，我们实际上没必要将 l 到 r 这一段区间划分成若干个小区间。为什么呢？我们求的是区间最大值，那么只需要用两个长度为 2 的幂次的区间恰好覆盖住 l 到 r 就可以了，这两个区间完全可以有重叠，因为我们求的是最大值。因此，设 $2^m\leq r-l+1 < 2^{m+1}$ ，我们可以利用两个长度为 $2^m$ 的区间覆盖住 l 到 r，因此

$ans=\max\{F[l][m],F[r-2^m+1][m]\}$

这个计算过程的时间复杂度是 O(1) 的，倍增算法出人意料地解决了这一问题，总时间复杂度（包括预处理和查询）为 $O(n\log n+m)$ 。此外还有一些细节，当我们根据区间长度 r-l+1 求 m 时，可以预处理相关的数组，来保证单次询问的时间复杂度为 O(1) 。

