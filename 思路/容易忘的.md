###### 结构体重载运算符
```cpp
struct edge{
    int w,u,v,next;
    bool operator<(edge b)const{return w>b.w;} 
    //从大到小排序(在sort中) 从小到大排序(在堆中)
}e[N],edge[N*2];
```
___
###### dij $O(n\log n)$ 
```cpp
inline void dijkstra(){
    dis[s]=0;
    q.push((node){0,s});
    while(!q.empty()){
        int x=q.top().pos,d=q.top().dis;
        q.pop();
        if(vis[x])continue;
        vis[x]=1;
        for(int i=head[x];i;i=e[i].next){
            int y=e[i].to;
            if(dis[y]>dis[x]+e[i].dis){
                dis[y]=dis[x]+e[i].dis;
                if(!vis[y])q.push((node){dis[y],y});
            }
        }
    }
}
```
___
###### 拓扑排序 $O(n)$
```cpp
queue<int>q;
for(int i=1;i<=n;++i)
    if(!in[i])q.push(i);
while(!q.empty()){
    int w=q.front();q.pop();
    cout<<w<<' ';
    for(int i:node[w]){
        in[i]--;if(!in[i])q.push(i);
    }
}
```
___
###### 优先队列
``priority_queue<int>
___
###### $O(1)$ map
```cpp
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace pb_ds;
gp_hash_table<int,bool>ma;
```
___
###### 环形结构
```
其次要注意的是在dp之前先枚举前五个的状态state，因为围栏是一个环，最后枚举第n+1个围栏时，其实就相当于又回到了第一个围栏，那么此时必须满足s=state才是有效状态，更新答案。
```
___
###### 快速幂
```cpp
int fastPow(int a, int n)
{
    int base = a; // 不用base直接用a也行
    int res = 1;  // 用res返回结果
    while (n)
    {
        if (n & 1) // 如果n的最后一位是1，表示这个地方需要乘
            res *= base;
        base *= base; // 推算乘积：a² --> (a²)² -->((a²)²)² ...
        n >>= 1;
    }
    return res;
}
```
___
###### 关于log
```
log的计算就是乘方的逆过程。
如果a的x次方等于N（a>0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=logaN。其中，a叫做对数的底数，N叫做真数。
计算方式：
根据2^3=8，可得log2 8=3。
**扩展资料**
对数的运算法则：
1、log(a) (M·N）=log(a) M+log(a) N
2、log(a) (M÷N)=log(a) M-log(a) N
3、log(a) M^n=nlog(a) M
4、log(a)b*log(b)a=1
5、log(a) b=log (c) b÷log (c) a
指数的运算法则：
1、[a^m]×[a^n]=a^(m＋n) 【同底数幂相乘,底数不变,指数相加】
2、[a^m]÷[a^n]=a^(m－n) 【同底数幂相除,底数不变,指数相减】
3、[a^m]^n=a^(mn) 【幂的乘方,底数不变,指数相乘】 
4、[ab]^m=(a^m)×(a^m) 【积的乘方,等于各个因式分别乘方,再把所得的幂相乘】
```
___
###### 一个数在二进制下 1 的个数
```cpp
__builtin_popcount(unsigned int n)//返回值为int[[problem]]
__builtin_popcountl(unsigned int n)//返回值为long
__builtin_popcountll(unsigned int n)//返回值为long long
```
___

###### 最小生成树版子
prim
```cpp
n^2的，不跑也罢！
```
Kruskal
```cpp
struct{
	int x,y,z;
}edge[500010];
int fa[100010],n,m,ans;
bool operator<(rec a,rec b){return a.z<b.z;}
int get(int x){
	if(x==fa[x])return x;
	return fa[x]=get(fa[x]);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		cin>>edge[i].x>>edge[i].y<<edge[i].z;
	}
	sort(edge+1,edge+m+1);
	for(int i=1;i<=n;++i)fa[i]=i;
	for(int i=1;i<=m;++i){
		int x=get(edge[i].x),y=get(edge[i].y);
		if(x==y)continue;
		fa[x]=y;
		ans+=edge[i].z;
	}
	cout<<ans<<endl;
}
```
###### 矩阵乘法/矩阵快速幂
```cpp
struct mt{
    int n,t[N][N];
    inline mt(){memset(t,0,sizeof(t));}
    inline void clear(){
        memset(t,0,sizeof(t));
        for(int i=1;i<=n;++i)t[i][i]=1;
    }
    inline mt operator*(const mt&b)const{
        mt res;int r;res.n=b.n;
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j){
                for(int k=1;k<=n;++k)
                    res.t[i][j]+=t[i][k]*b.t[k][j];
                res.t[i][j]%=mod;
            }
        return res;
    }
    inline mt operator^(int p)const{
        mt res,x=*this;res.n=x.n;
        res.clear();
        for(;p;p>>=1,x=x*x)
            if(p&1)res=res*x;
        return res;
    }
}base;
```

###### st表
```
这个忘不了吧
```
###### LCA
倍增跳（常数大，好吧并不是很大）
```cpp

```
树剖求（常数小）
```cpp

```
###### 树链剖分
就放个板子吧。
```cpp
```
###### 基础数论（待）
线性筛素数
```cpp
#include<bits/stdc++.h>
using namespace std;
int prime[int(1e7)+5];
bool vis[int (1e8)+5];
void getprime(int n){
	int m=0;
	for(int i=2;i<=n;i++){
		if(!vis[i])prime[++m]=i;
		for(int j=1;j<=m&&prime[j]*i<=n;++j){
			vis[prime[j]*i]=1;
			if(i%prime[j]==0)break;
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	int n,q;
	cin>>n>>q;
	getprime(n);int qu;
	for(int i=1;i<=q;i++){
		cin>>qu;
		cout<<prime[qu]<<'\n';
	}
}
```
---
exgcd
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b,x,y;
int read(){
	int x=0;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar());
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return x;
}
void exgcd(int a,int b){
	if(!b){
		x=1,y=0;return;
	}
	exgcd(b,a%b);
	int t=x;x=y;y=t-a/b*y;
}
main(){
	a=read(),b=read();
	exgcd(a,b);
	cout<<(x%b+b)%b;
}
```
---
gcd
```cpp
inline int gcd(int a,int b){
	if(!b)return a;
	return exgcd(b,a%b);
}
```
---
求逆元
单个（费马小定理）
```cpp
typedef long long ll
ll quickqpow(ll a,ll n,ll p){ //快速幂求a^n%p
	ll ans=1;
	while(n){
		if(n&1)ans=ans*a%p;
		a=a*a%p;
		n>>=1;
	}
	return ans;
}
```
线性
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
    for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
    return x*f;
}
int ny[int(3e6+5)];
int main(){
    cout.tie(0);
    int n=read(),p=read();ny[1]=1;cout<<1<<'\n';
    for(int i=2;i<=n;i++){
        ny[i]=(long long)(p-p/i)*ny[p%i]%p;
        cout<<ny[i]<<'\n';
    }
    return 0;
}
```

---
欧拉函数
单个
```cpp
int euler_phi(int n){
	int m=int(sqrt(n+0.5));
	int ans=n;
	for(int i=2;i<=m;++i){
		if(n%i==0){
			ans=ans/i*(i-1);
			while(n%i==0)n/=i;
		}
	}
	if(n>1)ans=ans/n*(n-1);
	return ans;
}
```
线性
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int p[N],vis[N],cnt,phi[N];
void get_phi(int n){
	phi[1]=1;
	for(int i=2;i<=n;++i){
		if(!vis[i]){
			p[++cnt]=i;
			phi[i]=i-1;
		}
	}
	for(int j=1;i*p[j]<=n;++j){
		int m=i*p[j];
		vis[m]=true;
		if(i%p[j]==0){
			phi[m]=p[j]*phi[i];
			break;
		}
		else 
			phi[m]=(p[j]-1)*phi[i];
	}
}
```
---
###### tarjan（待）
###### 二分图（待）
###### 树状数组（待）
###### 线段树
```
模拟赛天天考你还能忘？
```
###### 基础DP（待）
###### 单调队列 单调栈 悬线法（待）


